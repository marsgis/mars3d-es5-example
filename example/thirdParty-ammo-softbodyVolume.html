<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0,minimum-scale=1.0,maximum-scale=1.0" />
    <meta name="author" content="火星科技 http://mars3d.cn " />
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="x5-fullscreen" content="true" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
    <!-- 标题及搜索关键字 -->
    <meta name="keywords" content="火星科技,cesium,3D,GIS,marsgis,三维,地球,地图,开发,框架,系统,示例,资料,模型,离线,外包,合肥,安徽,中国" />
    <meta
      name="description"
      content="火星科技 合肥火星 合肥火星科技 合肥火星科技有限公司 leaflet leaflet框架 leaflet开发 cesium cesium开发 cesium框架 三维 地球 模型  gis marsgis 地图离线 地图开发 地图框架 地图外包 框架 开发 外包  地图离线 二维地图 三维地图 全景漫游 地理信息系统 云GIS 三维GIS GIS平台 WebGIS"
    />


    <link rel="shortcut icon" type="image/x-icon" href="https://muyao1987.gitee.io/cdn/marsgis.cn/favicon/favicon.ico" />
    <title>ammo物理引擎扩展支持  | Mars3D | 三维地图 | 火星科技 | 合肥火星科技有限公司</title>

    <script
      type="text/javascript"
      src="../lib/include-lib.js"
      libpath="../lib/"
      include="jquery,font-awesome,bootstrap,layer,haoutil,mars3d,cesium-meshVisualizer"
    ></script>

    <link href="css/style.css" rel="stylesheet" />
  </head>
  <body class="dark">
    <div id="mars3dContainer" class="mars3d-container"></div>

    <!-- 面板 -->
    <div class="infoview">操作提示：鼠标左键单击进行发射</div>


    <script src="./js/common.js"></script>
    <script type="text/javascript">
      "use script"; //开发环境建议开启严格模式

      let map;

      function initMap(options) {
        //合并属性参数，可覆盖config.json中的对应配置
        let mapOptions = mars3d.Util.merge(options, {
          scene: {
            center: { lat: 31.834648, lng: 117.219733, alt: 83, heading: 64, pitch: -34 },
            fxaa: true,
          },
        });

        //创建三维地球场景
        map = new mars3d.Map("mars3dContainer", mapOptions);

        //
        let MeshVisualizer = Cesium.MeshVisualizer;
        let Mesh = Cesium.Mesh;
        let MeshMaterial = Cesium.MeshMaterial;
        let FramebufferTexture = Cesium.FramebufferTexture;
        let GeometryUtils = Cesium.GeometryUtils;
        let MeshPhongMaterial = Cesium.MeshPhongMaterial;
        let BasicMeshMaterial = Cesium.BasicMeshMaterial;
        let LOD = Cesium.LOD;

        let center = Cesium.Cartesian3.fromDegrees(117.220206, 31.834866, 50);
        let modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);

        let meshVisualizer = new MeshVisualizer({
          modelMatrix: modelMatrix,
          up: { y: 1 },
          referenceAxisParameter: {
            length: 100,
            width: 0.05,
            headLength: 2,
            headWidth: 0.1,
          },
        });
        map.scene.primitives.add(meshVisualizer);
        meshVisualizer.showReference = true; //显示坐标轴

        function createRandomColor() {
          return Cesium.Color.fromRandom({ alpha: 1 }); //fromRgba(Math.floor(Math.random() * (1 << 24)));
        }
        function createMaterial() {
          return new MeshPhongMaterial({
            defaultColor: createRandomColor(),
            side: MeshMaterial.Sides.DOUBLE,
            translucent: false,
          });
        }

        Cesium.Cartesian3.prototype.set = function (x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        };
        Cesium.Cartesian2.prototype.set = function (x, y) {
          this.x = x;
          this.y = y;
        };
        Cesium.Quaternion.prototype.set = function (x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        };

        Ammo().then(function () {
          // - Global variables -

          // Graphics variables
          let clickRequest = false;
          let mouseCoords = new Cesium.Cartesian2();
          let ballMaterial = createMaterial();
          let pos = new Cesium.Cartesian3();
          let quat = new Cesium.Quaternion();

          // Physics variables
          let gravityConstant = -9.8;
          let collisionConfiguration;
          let dispatcher;
          let broadphase;
          let solver;
          let physicsWorld;
          let rigidBodies = [];
          let softBodies = [];
          let margin = 0.05;
          let hinge;
          let transformAux1 = new Ammo.btTransform();
          let softBodyHelpers = new Ammo.btSoftBodyHelpers();
          let armMovement = 0;
          let ray = new Cesium.Ray();
          let softBodySolver;

          function initPhysics() {
            // Physics configuration

            collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
            dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            broadphase = new Ammo.btDbvtBroadphase();
            solver = new Ammo.btSequentialImpulseConstraintSolver();
            softBodySolver = new Ammo.btDefaultSoftBodySolver();
            physicsWorld = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
            physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant, 0));
            physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, gravityConstant, 0));
          }

          function createObjects() {
            // Ground
            pos.set(0, -0.5, 0);
            quat.set(0, 0, 0, 1);
            let ground = createParalellepiped(
              40,
              1,
              40,
              0,
              pos,
              quat,
              new MeshPhongMaterial({
                defaultColor: "rgb(200,200,200)",
                side: MeshMaterial.Sides.DOUBLE,
                translucent: false,
              })
            );
            GeometryUtils.computeVertexNormals(ground.geometry);

            // Create soft volumes
            let volumeMass = 15;

            let sphereGeometry = new THREE.SphereBufferGeometry(1.5, 40, 25);
            sphereGeometry.translate(5, 5, 0);
            createSoftVolume(sphereGeometry, volumeMass, 250);

            let boxGeometry = new THREE.BufferGeometry().fromGeometry(new THREE.BoxGeometry(1, 1, 5, 4, 4, 20));
            boxGeometry.translate(-2, 5, 0);
            createSoftVolume(boxGeometry, volumeMass, 120);

            // Ramp
            pos.set(3, 1, 0);
            Cesium.Quaternion.fromAxisAngle(new Cesium.Cartesian3(0, 0, 1), (30 * Math.PI) / 180, quat);
            let obstacle = createParalellepiped(
              10,
              1,
              4,
              0,
              pos,
              quat,
              new MeshPhongMaterial({
                defaultColor: "rgb(28,28,28)",
                side: MeshMaterial.Sides.DOUBLE,
                translucent: false,
              })
            );
            GeometryUtils.computeVertexNormals(obstacle.geometry);
          }

          function processGeometry(bufGeometry) {
            // Obtain a Geometry
            let geometry = new THREE.Geometry().fromBufferGeometry(bufGeometry);

            // Merge the vertices so the triangle soup is converted to indexed triangles
            let vertsDiff = geometry.mergeVertices();

            // Convert again to BufferGeometry, indexed
            let indexedBufferGeom = createIndexedBufferGeometryFromGeometry(geometry);

            // Create index arrays mapping the indexed vertices to bufGeometry vertices
            mapIndices(bufGeometry, indexedBufferGeom);
          }

          function createIndexedBufferGeometryFromGeometry(geometry) {
            let numVertices = geometry.vertices.length;
            let numFaces = geometry.faces.length;

            let bufferGeom = new THREE.BufferGeometry();
            let vertices = new Float32Array(numVertices * 3);
            let indices = new (numFaces * 3 > 65535 ? Uint32Array : Uint16Array)(numFaces * 3);

            for (let i = 0; i < numVertices; i++) {
              let p = geometry.vertices[i];

              let i3 = i * 3;

              vertices[i3] = p.x;
              vertices[i3 + 1] = p.y;
              vertices[i3 + 2] = p.z;
            }

            for (let i = 0; i < numFaces; i++) {
              let f = geometry.faces[i];

              let i3 = i * 3;

              indices[i3] = f.a;
              indices[i3 + 1] = f.b;
              indices[i3 + 2] = f.c;
            }

            bufferGeom.setIndex(new THREE.BufferAttribute(indices, 1));
            bufferGeom.addAttribute("position", new THREE.BufferAttribute(vertices, 3));

            return bufferGeom;
          }

          function isEqual(x1, y1, z1, x2, y2, z2) {
            let delta = 0.000001;
            return Math.abs(x2 - x1) < delta && Math.abs(y2 - y1) < delta && Math.abs(z2 - z1) < delta;
          }

          function mapIndices(bufGeometry, indexedBufferGeom) {
            // Creates ammoVertices, ammoIndices and ammoIndexAssociation in bufGeometry

            let vertices = bufGeometry.attributes.position.array;
            let idxVertices = indexedBufferGeom.attributes.position.array;
            let indices = indexedBufferGeom.index.array;

            let numIdxVertices = idxVertices.length / 3;
            let numVertices = vertices.length / 3;

            bufGeometry.ammoVertices = idxVertices;
            bufGeometry.ammoIndices = indices;
            bufGeometry.ammoIndexAssociation = [];

            for (let i = 0; i < numIdxVertices; i++) {
              let association = [];
              bufGeometry.ammoIndexAssociation.push(association);

              let i3 = i * 3;

              for (let j = 0; j < numVertices; j++) {
                let j3 = j * 3;
                if (isEqual(idxVertices[i3], idxVertices[i3 + 1], idxVertices[i3 + 2], vertices[j3], vertices[j3 + 1], vertices[j3 + 2])) {
                  association.push(j3);
                }
              }
            }
          }

          function createSoftVolume(bufferGeom, mass, pressure) {
            processGeometry(bufferGeom);

            let volume = new Mesh(
              bufferGeom,
              new BasicMeshMaterial({
                uniforms: {
                  diffuseColorMap: "img/textures/colors.png",
                },
                translucent: false,
              })
            );
            volume.geometry.ammoIndexAssociation = bufferGeom.ammoIndexAssociation;

            meshVisualizer.add(volume);

            // Volume physic object

            let volumeSoftBody = softBodyHelpers.CreateFromTriMesh(
              physicsWorld.getWorldInfo(),
              bufferGeom.ammoVertices,
              bufferGeom.ammoIndices,
              bufferGeom.ammoIndices.length / 3,
              true
            );

            let sbConfig = volumeSoftBody.get_m_cfg();
            sbConfig.set_viterations(40);
            sbConfig.set_piterations(40);

            // Soft-soft and soft-rigid collisions
            sbConfig.set_collisions(0x11);

            // Friction
            sbConfig.set_kDF(0.1);
            // Damping
            sbConfig.set_kDP(0.01);
            // Pressure
            sbConfig.set_kPR(pressure);
            // Stiffness
            volumeSoftBody.get_m_materials().at(0).set_m_kLST(0.9);
            volumeSoftBody.get_m_materials().at(0).set_m_kAST(0.9);

            volumeSoftBody.setTotalMass(mass, false);
            Ammo.castObject(volumeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(margin);
            physicsWorld.addSoftBody(volumeSoftBody, 1, -1);
            volume.physicsBody = volumeSoftBody;
            // Disable deactivation
            volumeSoftBody.setActivationState(4);

            softBodies.push(volume);
          }

          function createParalellepiped(sx, sy, sz, mass, pos, quat, material) {
            let box = Cesium.BoxGeometry.fromDimensions({
              dimensions: new Cesium.Cartesian3(sx, sy, sz),
              vertexFormat: new Cesium.VertexFormat({
                position: true,
                normal: true,
              }),
            });
            let threeObject = new Mesh(box, material);

            let shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
            shape.setMargin(margin);

            createRigidBody(threeObject, shape, mass, pos, quat);

            return threeObject;
          }

          function createRigidBody(threeObject, physicsShape, mass, pos, quat) {
            Cesium.Cartesian3.clone(pos, threeObject.position);
            if (!threeObject.quaternion) {
              threeObject.quaternion = new Cesium.Quaternion();
            }
            Cesium.Quaternion.clone(quat, threeObject.quaternion);

            let transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
            transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
            let motionState = new Ammo.btDefaultMotionState(transform);

            let localInertia = new Ammo.btVector3(0, 0, 0);
            physicsShape.calculateLocalInertia(mass, localInertia);

            let rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
            let body = new Ammo.btRigidBody(rbInfo);

            threeObject.physicsBody = body;

            meshVisualizer.add(threeObject);

            if (mass > 0) {
              rigidBodies.push(threeObject);

              // Disable deactivation
              body.setActivationState(4);
            }

            physicsWorld.addRigidBody(body);

            return body;
          }

          function updatePhysics(deltaTime) {
            try {
              // Step world
              physicsWorld.stepSimulation(deltaTime, 10);

              // Update soft volumes
              for (let i = 0, il = softBodies.length; i < il; i++) {
                let volume = softBodies[i];
                let geometry = volume.geometry;
                let softBody = volume.physicsBody;
                let volumePositions = geometry.attributes.position.values;
                let volumeNormals = geometry.attributes.normal.values;
                let association = geometry.ammoIndexAssociation;
                let numVerts = association.length;
                let nodes = softBody.get_m_nodes();
                for (let j = 0; j < numVerts; j++) {
                  let node = nodes.at(j);
                  let nodePos = node.get_m_x();
                  let x = nodePos.x();
                  let y = nodePos.y();
                  let z = nodePos.z();
                  let nodeNormal = node.get_m_n();
                  let nx = nodeNormal.x();
                  let ny = nodeNormal.y();
                  let nz = nodeNormal.z();

                  let assocVertex = association[j];

                  for (let k = 0, kl = assocVertex.length; k < kl; k++) {
                    let indexVertex = assocVertex[k];
                    volumePositions[indexVertex] = x;
                    volumeNormals[indexVertex] = nx;
                    indexVertex++;
                    volumePositions[indexVertex] = y;
                    volumeNormals[indexVertex] = ny;
                    indexVertex++;
                    volumePositions[indexVertex] = z;
                    volumeNormals[indexVertex] = nz;
                  }
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.normal.needsUpdate = true;

                volume.modelMatrixNeedsUpdate = true;
              }

              // Update rigid bodies
              for (let i = 0, il = rigidBodies.length; i < il; i++) {
                let objThree = rigidBodies[i];
                let objPhys = objThree.physicsBody;
                let ms = objPhys.getMotionState();
                if (ms) {
                  ms.getWorldTransform(transformAux1);
                  let p = transformAux1.getOrigin();
                  let q = transformAux1.getRotation();
                  objThree.position.set(p.x(), p.y(), p.z());
                  objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
                  objThree.modelMatrixNeedsUpdate = true;
                }
              }
            } catch (e) {
              meshVisualizer.beforeUpdate.removeEventListener(update);
              console.log("崩溃了", e);
            }
          }

          let start = false;
          let init = false;
          let startTime = new Date();
          let rayDir = new Cesium.Cartesian3();
          let maxDistance = 100; //发射点与射线和局部场景的交点的距离不能太远，过远会撕碎软体进而碎片过多时导致ammo物理引擎崩溃

          function initInput() {
            let scene = map.scene;
            let handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
            let lastMesh = null;
            handler.setInputAction(function (movement) {
              if (!clickRequest) {
                Cesium.Cartesian2.clone(movement.position, mouseCoords);
                clickRequest = true;
              }
            }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
          }

          function processClick() {
            if (clickRequest) {
              meshVisualizer.getPickRay(mouseCoords, ray);
              if (!ray) {
                clickRequest = false;
                return;
              }
              // Creates a ball
              let ballMass = 3;
              let ballRadius = 0.4;

              let ball = new Mesh(new THREE.SphereGeometry(ballRadius, 18, 16), ballMaterial);

              let ballShape = new Ammo.btSphereShape(ballRadius);
              ballShape.setMargin(margin);

              Cesium.Cartesian3.clone(ray.direction, rayDir);
              Cesium.Cartesian3.subtract(ray.origin, ray.direction, pos);

              quat.set(0, 0, 0, 1);
              let ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);
              ballBody.setFriction(0.5);

              Cesium.Cartesian3.normalize(rayDir, rayDir);
              Cesium.Cartesian3.multiplyByScalar(rayDir, 30, rayDir);
              // console.log(rayDir);
              ballBody.setLinearVelocity(new Ammo.btVector3(rayDir.x, rayDir.y, rayDir.z));

              clickRequest = false;
            }
          }
          function update(frameState) {
            let deltaTime = (new Date() - startTime) / 1000.0;
            updatePhysics(deltaTime);
            processClick();
            startTime = new Date();
          }
          setTimeout(function () {
            if (!init) {
              // - Init -
              //initGraphics();

              initPhysics();

              createObjects();

              initInput();

              init = true;
            }
            if (!start) {
              meshVisualizer.beforeUpdate.addEventListener(update);
              start = true;
            } else {
              meshVisualizer.beforeUpdate.removeEventListener(update);
              start = false;
            }
          }, 1000 * 3);
        });
      }
    </script>
  </body>
</html>
